<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
    <!-- 
    let 和 var 区别：
      1、let不允许重复声明变量，会报错
      2、let不存在变量提升，会报错
      3、let存在一个块级作用域的概念：一个{}就是一个块级作用域，let声明的变量只能在声明他的{}中获取到
      4、暂时性死区：【在一个作用域内不允许同名变量进来】，当用let去声明一个变量的时候，就会形成一个封闭的死区，只能在声明后调用，否则就会报错
   -->
    <script>
        // var str = 'ddd';
        // var str = 'ggg';
        // console.log(str);//ggg

        // let str = 'ddd';
        // let str = 'ggg';
        // console.log(str);//Identifier 'str' has already been declared
        //let 不允许重复声明一个变量


        // console.log(str);//undefined
        // var str = 'ddd';
        // 变量提升
        // var str;
        // console.log(str);
        // str = 'ddd';

        // console.log(str);//Cannot access 'str' before initialization
        // let str = 'ddd';
        //let 不存在变量提升



        /*
          作用域：
            1、全局作用域
            2、局部作用域（函数作用域）
            3、块级作用域：es6: 一个{}就是一个块级作用域，let声明的变量只能在声明他的{}中获取到
        */

        /*  3、let存在一个块级作用域的概念 */


        // if (true) {
        //     var a = 10;
        // }
        // console.log(a);//10

        // if (true) {
        //     let b = 10;
        // }
        // console.log(b);// b is not defined 块级作用域


        // for (var i = 0; i < 3; i++) {
        //   console.log(i);
        // }
        // console.log(i); //3

        // for (let i = 0; i < 3; i++) {
        //   console.log(i);
        // }
        // console.log(i); //i is not defined:块级作用域
        
        let aLi = document.getElementsByTagName('li');
        // for (var i = 0; i < aLi.length; i++) {
        //   aLi[i].onclick = function () {
        //     console.log(i);
        //   }
        // }
        // console.log(i);

        // let:原理和闭包一样
        // for (let i = 0; i < aLi.length; i++) {
        //   aLi[i].onclick = function () {
        //     console.log(i);
        //   }
        // }

        // 闭包：外部函数中声明了内部函数，内部函数中引用了外部函数中的局部变量，这样外部函数执行完毕之后内存不释放
        // for (var i = 0; i < aLi.length; i++) {
        //   (function () {
        //     var index = i;
        //     aLi[i].onclick = function () {
        //       console.log(index);
        //     }
        //   })()
        //   // console.log(index);
        // }

        // for (var i = 0; i < aLi.length; i++) {
        //   (function (index) { //形参
        //     var index = i;
        //     aLi[i].onclick = function () {
        //       console.log(index);
        //     }
        //   })(i) //实参
        // }

         // 见阶段复习js1.let.html以及1-变量声明.html

        /* 4、暂时性死区 */
        var a = 88;

        function fn1() {
            console.log(a); //undefined: 局部作用域内变量提升
            var a = 888;
        }
        fn1();

        var b = 99;

        function fn2() {
            console.log(b); //会报错：暂时性死区
            let b = 999;
        }
        fn2();
       

    </script>
</body>

</html>